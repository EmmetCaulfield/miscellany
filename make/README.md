GNU Make Templates for C, C++, and CUDA Development
===================================================

This directory contains _GNU Make_ templates for generating
development Makefiles for simple _C_, _C++_, and _CUDA_ projects.

Three Makefiles are generated by typing `make` in this directory and
can be deleted with `make clean`:

  * [Makefile.gcc](Makefile.gcc)
  * [Makefile.g++](Makefile.g++)
  * [Makefile.cuda](Makefile.cuda)

The idea is that you can pick one, copy it, make a _small_ edit to add
the source file(s) that contain a `main()` function, and then have a
fully-featured `Makefile` for development purposes.

Each `Makefile` provides a number of utility targets that alter the
way the binaries are compiled, which is extremely useful, although
somewhat unusual. For example, you simply do `make debug` to generate
a debug binary or `make gprof` to make a profiling binary.

The utility targets are mostly aimed at _C_/_C++_ development, and
may, or may not, be useful for or applicable to _CUDA_ development,
which has a couple of its own targets.

Where there are _xxx_ and _xxx0_ versions of a utility target, the
_xxx_ version leaves the optimization flag alone, while the _xxx0_
version removes any `-Ox` flag so the compiler defaults to no
optimization, equivalent to `-O0`.

  * ['debug' & 'debug0'](bits/debug.mk) — generate debug binaries
  * ['gprof' & 'gprof0'](bits/gprof.mk) — generate instrumented binaries for `gprof`
  * ['gcov' & 'gcov0'](bits/gcov.mk) — generate instrumented binaries for `gcov`
  * ['pdo1' & 'pdo2'](bits/pdo.mk) — two compilation phases for profile-directed optimization

Additional utility targets in the _CUDA_ `Makefile` only are:

  * ['regcount'](bits/CUDA.mk) — compile and extract register counts for kernels
  * ['verbose'](bits/CUDA.mk) — invoke `nvcc` with `-v` flag

Some implicit rules are provided:

  * [%.c/%.cpp -> %.d](bits/deps.mk) — automatic dependency generation
  * [%.c/%.cpp -> %.s](bits/asm.mk) — compiler assembly output
  * [%.c/%.cpp -> %.i](bits/ppc.mk) — compiler post-processed _C/C++_ output
  * [%.h -> %.h.gch](bits/pch.mk) — precompiled header support
  * [%.cu -> %.cpp.ii](bits/CUDA.mk) — CUDA post-processed _C++_ output
  * [% -> %.vg](bits/valgrind.mk) — save `valgrind` output
  
Some more conventional utility targets are provided:

  * [doc](bits/doxygen.mk) — run _Doxygen_ on all sources
  * [valgrind](bits/valgrind.mk) — run _valgrind_ on all binaries

As well as a couple of unconventional targets:

  * [ignores.lst](bits/ignores.mk) — generated file of updated `git`/`svn` ignores
  * [smake.env](bits/smake.mk) — emits a shell function, `smake` that, when used instead of `make`, saves output to `smake.out` and `smake.err`

And one, [local.mk](bits/local.mk) that has local CUDA customization
for me, which you should probably ignore or delete.

Overview
--------

### Partitioning of Variables ###

#### CFLAGS or CXXFLAGS ####

One of the main “odd” features of these `Makefile`s are that the
standard implicit compiler flags variables, `CFLAGS` or `CXXFLAGS`
(for _C_ or _C++_/_CUDA_, respectively), are partitioned into 5
variables:

  * `LANG_FLAGS` — language options, e.g. `-std=c++11 -pedantic`
  * `WARN_FLAGS` — warning flags, e.g. `-Wall -Wextra`
  * `OPTM_FLAGS` — optimization flags, e.g. `-O3 -march=native`
  * `PROF_FLAGS` — profiling flags, e.g. `-pg`
  * `DBUG_FLAGS` — debug flags, e.g. `-ggdb3`

The first 3, you can change any way you like. The final 2, you should
have no reason to muck around with, because what you normally might
want to do with them is enabled by the `debug` and `gprof` utility
targets.

#### RT_FILES, CT_FILES, & MC_FILES ####

The `Makefile`s maintain 3 lists of filenames, or globs (if
`USE_GLOBS` is set to `yes`), for `clean` targets:

  * `RT_FILES` — Run-time files generated by the program or profiling tools;
  * `CT_FILES` — Compile-time files generated by the compiler, etc.; and
  * `MC_FILES` — Make-control files that determine how make behaves.

Each major rule in the `Makefile` is followed by a stanza where the
files that it deals with are added to the appropriate list. This can,
perhaps, be most clearly seen in the files in [bits/](bits/): any that
might lead to the generation of files have a stanza at the end that
adds those files to the appropriate list.

