# -*- makefile-gmake -*-

# List any source files, including their extension, containing a
# "main()" function:
MAIN:=

# If there are *other* sources, not having a main(), list them here:
SRCS:=$(filter-out $(MAIN) *.cpp,$(shell echo *.cpp))

# List all headers files here:
HDRS:=$(filter-out *.h,$(shell echo *.h))

# List files generated by MAIN that should be deleted by the 'clean'
# rule, if any:
RT_FILES:=

# Decide whether to use precompiled headers:
USE_PCH:=yes

# Decide whether to use globs or not:
USE_GLOBS:=yes


#======================================================================
# STANDARD IMPLICIT VARIABLES
#----------------------------------------------------------------------
CXX=g++

# Preprocessor flags; -DNDEBUG is removed by 'debug' targets.
CPPFLAGS:=-I. -DNDEBUG

# Compiler flags; change the 5 *_FLAGS variables, below, not this
# definition, which must remain recursive:
CXXFLAGS=$(DBUG_FLAGS) $(LANG_FLAGS) $(PROF_FLAGS) $(WARN_FLAGS) $(OPTM_FLAGS)

# Linker flags; 'debug', 'gprof', and 'pdo' targets append to LDFLAGS:
LDFLAGS:=

# Linker libs; 'gcov' targets append to LDLIBS
LDLIBS:=-lstdc++
#======================================================================


#======================================================================
# 5 *_FLAGS VARIABLES
#
# What follows are non-standard variables that are combined to produce
# _FMV_, a standard implicit variable, per the definition above. The
# reason for doing this is to have the flexibility to work around
# certain bugs in 'nvcc'; in particular, to have the ability to
# exclude language option flags (LANG_FLAGS), which can cause it to
# choke.
#----------------------------------------------------------------------
# Warning and error flags; these are not altered by utility targets:
WARN_FLAGS:=-Wall -Wextra

# Language option flags; these are not altered by utility targets:
LANG_FLAGS:=-std=c++11 -pedantic

# Optimization flags; the level (-Ox) is removed by the 'debug0',
# 'gprof0', and 'gcov0' targets, and (potentially) altered by the
# 'O0', 'O1', 'O2', 'O3', 'Os', 'Ofast', and 'Og' targets.
OPTM_FLAGS:=-O3 -march=native

# Profiling and DBUG flags. These flags are SET by utility targets
# ('debug', 'debug0', 'gprof', 'gprof0', 'gcov', 'gcov0', 'pdo1',
# 'pdo2') whose entire reason for existing is to obviate the need to
# alter compiler flags for profiling or debugging, so setting them
# directly circumvents the purpose of those targets and is not
# recommended:
PROF_FLAGS:=
DBUG_FLAGS:=

# Debug options to use in 'debug' and 'debug0' utility targets
# (i.e. only when debug binaries are built).
# 
# Although everyone just seems to use '-g', gcc's debugging
# information goes well beyond it.
#
# In summary (see gcc manual for details), there are two things to
# choose from:
#
#    -g<format>, with <format> one of:
#         stabs       : old Unix format, used by Solaris
#         stabs+      :     stabs with gdb-only extensions
#	  coff        : old Unix format, basis of XCOFF and ECOFF
#         xcoff       : IBM/AIX flavor of coff
#         xcoff+      :     xcoff with gdb-only extensions
#         vms         : DEC Alpha/VMS format
#         dwarf-<ver> : most modern Unixen (<ver> 2, 3, or 4)
#         gdb         : choose most expressive supported format
#         <format>+   : allow gdb extensions to <format>
#
#    -g<level>, <level> one of:
#         0 : disable debug info
#         1 : minimal - functions & externs, enough for backtraces
#         2 : default - 1 + local vars and line numbers
#         3 : extra   - 2 + extras such as macros
#
# So -g on a modern Linux box is most likely equivalent to -gdwarf-4 -g2.
#
# If I fire up a debugger, it's most likely going to be 'gdb', so I
# see no reason not to enable level 3 debug info and allow gdb
# extensions:
DBUG_OPTS:=-ggdb3
#======================================================================


# Binaries we're going to build:
BINS:=$(basename $(MAIN))

# This makefile:
THIS:=$(lastword $(MAKEFILE_LIST))

# Remember to delete the binaries:
CT_FILES:=$(BINS)

# Stems of ALL source files:
STMS:=$(BINS) $(basename $(SRCS))

# Let the builtin implicit rule build object-code files:
OBJS:=$(addsuffix .o,$(basename $(SRCS)))
ifeq ($(USE_GLOBS),yes)
CT_FILES+=*.o
else
CT_FILES+=$(STMS:=.o)
endif

# Dependency files:
DEPS:=$(STMS:=.d)

# Default rule: build the binaries!
default: build

-include _last.mk
ifeq ($(LAST),$(MAKECMDGOALS))
  build_deps:=$(BINS) _last.mk
else
  build_deps:=compile-time-clean $(BINS) _last.mk
endif
build: $(build_deps)


# Implicit rule to build binaries, which assumes that binaries depend
# on all the other object-code files, i.e. the ones in $(OBJS), which
# come from sources without a main().
%: %.o $(OBJS)
	$(CXX) $(LDFLAGS) -o $@ $^ $(LDLIBS)


# Include bits here:



#===[ bits/pch.mk ]====================================================
# pch: precompiled header support
#----------------------------------------------------------------------
%.h.gch: %.h
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -o $@ $<
pch: $(HDRS:=.gch)

ifeq ($(USE_GLOBS),yes)
CT_FILES:=$(sort *.h.gch $(CT_FILES))
else
CT_FILES:=$(sort $(HDRS:=.gch) $(CT_FILES))
endif
#======================================================================

#===[ bits/debug.mk ]==================================================
# debug, debug0. debugg: make debug binaries.
#
# The 'debug' target leaves optimization alone, while the 'debug0'
# target disables optimization, and the 'debugg' target enables -Og,
# the recommended optimization level for development. All three
# targets remove -DNDEBUG, if present, which disables assert() macros,
# so that assert macros() are enabled.
# ----------------------------------------------------------------------
ifneq (,$(filter debug,$(MAKECMDGOALS)))
CPPFLAGS:=$(subst -DNDEBUG,,$(CPPFLAGS))
DBUG_FLAGS:=$(DBUG_OPTS)
LDFLAGS+=$(DBUG_OPTS)
endif
debug: build

ifneq (,$(filter debug0,$(MAKECMDGOALS)))
CPPFLAGS:=$(subst -DNDEBUG,,$(CPPFLAGS))
OPTM_FLAGS:=$(filter-out -O%,$(OPTM_FLAGS))
DBUG_FLAGS:=$(DBUG_OPTS)
LDFLAGS+=$(DBUG_OPTS)
endif
debug0: build

ifneq (,$(filter debugg,$(MAKECMDGOALS)))
CPPFLAGS:=$(subst -DNDEBUG,,$(CPPFLAGS))
OPTM_FLAGS:=$(filter-out -O%,$(OPTM_FLAGS))
OPTM_FLAGS+=-Og
DBUG_FLAGS:=$(DBUG_OPTS)
LDFLAGS+=$(DBUG_OPTS)
endif
debugg: build
#======================================================================

#===[ bits/optim.mk ]==================================================
# O0, O1, O2, O3, Os, Ofast, Og: targets for every optimization level
# supported by 'gcc'
#----------------------------------------------------------------------
ifneq (,$(filter O0,$(MAKECMDGOALS)))
OPTM_FLAGS:=$(filter-out -O%,$(OPTM_FLAGS))
OPTM_FLAGS+=-O0
endif
O0: build

ifneq (,$(filter O1,$(MAKECMDGOALS)))
OPTM_FLAGS:=$(filter-out -O%,$(OPTM_FLAGS))
OPTM_FLAGS+=-O1
endif
O1: build

ifneq (,$(filter O2,$(MAKECMDGOALS)))
OPTM_FLAGS:=$(filter-out -O%,$(OPTM_FLAGS))
OPTM_FLAGS+=-O2
endif
O2: build

ifneq (,$(filter O3,$(MAKECMDGOALS)))
OPTM_FLAGS:=$(filter-out -O%,$(OPTM_FLAGS))
OPTM_FLAGS+=-O3
endif
O3: build

ifneq (,$(filter Os,$(MAKECMDGOALS)))
OPTM_FLAGS:=$(filter-out -O%,$(OPTM_FLAGS))
OPTM_FLAGS+=-Os
endif
Os: build

ifneq (,$(filter Ofast,$(MAKECMDGOALS)))
OPTM_FLAGS:=$(filter-out -O%,$(OPTM_FLAGS))
OPTM_FLAGS+=-Ofast
endif
Ofast: build

ifneq (,$(filter Og,$(MAKECMDGOALS)))
OPTM_FLAGS:=$(filter-out -O%,$(OPTM_FLAGS))
OPTM_FLAGS+=-Og
endif
Og: build
#======================================================================

#===[ bits/gprof.mk ]==================================================
# gprof, gprof0: make instrumented (profiling) binaries for 'gprof'.
#
# Since you *can* profile optimized binaries, both 'gprof' and
# 'gprof0' targets are provided, which leave optimization alone and
# disable optimization, respectively.
#----------------------------------------------------------------------
ifneq (,$(filter gprof,$(MAKECMDGOALS)))
PROF_FLAGS:=-pg
LDFLAGS+=-pg
endif
gprof: build

ifneq (,$(filter gprof0,$(MAKECMDGOALS)))
OPTM_FLAGS:=$(filter-out -O%,$(OPTM_FLAGS))
PROF_FLAGS:=-pg
LDFLAGS+=-pg
endif
gprof0: build

RT_FILES:=$(sort gmon.out $(RT_FILES))
#======================================================================

#===[ bits/gcov.mk ]===================================================
# gcov, gcov0: coverage analysis targets for 'gcov'.
#
# The 'gcov' manpage explicitly states that binaries should be built
# without optimization, but since we *can* do coverage analysis at
# some level with optimization on, two targets are provided: 'gcov',
# which leaves the optimization flag alone, and 'gcov0', which removes
# it (causing gcc to default to -O0).
#
# Generated files:
#
#     * -fprofile-arcs causes the executable to generate .gcda files
#           for each source file;
#     * -ftest-coverage causes the executable to generate .gcno files
#           for each source file
#     * gcov, run after the executable, itself generates .gcov files
#           for each source file
ifneq (,$(filter gcov,$(MAKECMDGOALS)))
PROF_FLAGS:=-fprofile-arcs -ftest-coverage
LDLIBS+=-lgcov
endif
gcov: build

ifneq (,$(filter gcov0,$(MAKECMDGOALS)))
OPTM_FLAGS:=$(filter-out -O%,$(OPTM_FLAGS))
PROF_FLAGS:=-fprofile-arcs -ftest-coverage
LDLIBS+=-lgcov
endif
gcov0: build

ifeq ($(USE_GLOBS),yes)
RT_FILES:=$(sort *.gcda *.gcno *.gcov $(RT_FILES))
else
RT_FILES:=$(sort $(STMS:=.gcda) $(STMS:=.gcno) $(STMS:=.gcov) $(RT_FILES))
endif
#======================================================================

#===[ bits/deps.mk ]===================================================
# deps: generate C/C++ dependencies automagically.
#----------------------------------------------------------------------
%.d: %.cpp
ifeq ($(USE_PCH),yes)
	$(CXX) -MM $(subst -MMD,,$(CPPFLAGS)) $(CXXFLAGS) $^ | sed 's/\.h\>/.h.gch/g' > $@
else
	$(CXX) -MM $(subst -MMD,,$(CPPFLAGS)) $(CXXFLAGS) -o $@ $^
endif
deps: $(DEPS)

ifeq ($(USE_GLOBS),yes)
MC_FILES:=$(sort *.d $(MC_FILES))
else
MC_FILES:=$(sort $(DEPS) $(MC_FILES))
endif
#======================================================================

#===[ bits/ppc.mk ]====================================================
# ppc: generate post-preprocessed code, sometimes needed for debugging
# preprocessor macros.
#----------------------------------------------------------------------
%.i: %.cpp
	$(CXX) -E $(CPPFLAGS) $(CXXFLAGS) -o $@ $^
ppc: $(STMS:=.i)

ifeq ($(USE_GLOBS),yes)
CT_FILES:=$(sort *.i $(CT_FILES))
else
CT_FILES:=$(sort $(STMS:=.i) $(CT_FILES))
endif
#======================================================================

#===[ bits/asm.mk ]====================================================
# asm: generate assembly language output from compilation proper.
#----------------------------------------------------------------------
#
# You arguably get better assembly output by supplying flags to gas
# rather than relying on whatever gcc provides with -fverbose-asm
#
# The 'a' flags of interest are:
#    'c' - omit false conditionals
#    'd' - omit debugging directives
#    'g' - include general information, like version and options
#    'h' - include high-level source
#    'l' - include assembly
#    'm' - include macro expansions
#    'n' - omit forms processing
#    's' - include symbols
S_ASFLAGS=-aghlnms
%.s: %.cpp
#	$(_CMV_) -S -fverbose-asm $(CPPFLAGS) $(_FMV_) -o $@ $^
	$(CXX) -Wa,$(S_ASFLAGS) $(CPPFLAGS) $(CXXFLAGS) -o $@ $^
asm:  $(STMS:=.s)

# Ensure that '-g' (debug info) flag is supplied, otherwise the output
# is much less readable.
ifneq (,$(filter asm,$(MAKECMDGOALS)))
DBUG_FLAGS:=$(DBUG_OPTS)
endif

ifeq ($(USE_GLOBS),yes)
CT_FILES:=$(sort *.s $(CT_FILES))
else
CT_FILES:=$(sort $(STMS:=.s) $(CT_FILES))
endif
#======================================================================

#===[ bits/doxygen.mk ]================================================
# doxygen: run doxygen on source and header files
#----------------------------------------------------------------------
NODEPS+=doc
doc: $(SRCS) $(HDRS)
	doxygen

RT_FILES:=$(sort doc, $(RT_FILES))
#======================================================================

#===[ bits/valgrink.mk ]===============================================
# valgrind: to check for memory leaks
#----------------------------------------------------------------------
NODEPS+=valgrind
valgrind: $(BINS:=.vg)

%.vg: %
	valgrind --log="$@" ./$<

ifeq ($(USE_GLOBS),yes)
RT_FILES:=$(sort *.vg $(RT_FILES))
else
RT_FILES:=$(sort $(BINS:=.vg) $(RT_FILES))
endif
#======================================================================




# Remove runtime-generated files
NODEPS+=run-time-clean
run-time-clean:
	rm -f $(RT_FILES) core core.*

# Remove compile-time generated files
NODEPS+=compile-time-clean
compile-time-clean:
	rm -f $(CT_FILES) *~

# Remove make control files:
NODEPS+=make-control-clean
make-control-clean:
	rm -f $(MC_FILES)

# Remove everything we know how to delete:
NODEPS+=clean
clean: make-control-clean compile-time-clean run-time-clean


# Make a record of this make run:
NODEPS+=_last.mk
_last.mk:
	@echo 'LAST:=$(MAKECMDGOALS)' > $@
MC_FILES+=_last.mk


# Silently extract phony targets from this Makefile:
NODEPS+=_phonies.mk
phonies.mk: $(THIS)
	@echo -n 'PHONY:=_last.mk ' > $@
	@grep -E '^[a-z][a-z0-]+:([^=]|$$)' $< |cut -d: -f1 |grep -v '^doc$$' \
		|tr '\n' ' ' >> $@
	@echo '\n.PHONY: $$(PHONY)' >> $@
MC_FILES+=_phonies.mk
-include _phonies.mk


# Include automagic dependencies for all targets except the ones we
# explictly exclude:
ifeq (,$(filter $(NODEPS),$(MAKECMDGOALS)))
-include $(DEPS)
endif

